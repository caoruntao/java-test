# JAVA

## 特性

### 面向对象

1. 封装
2. 继承
3. 多态

### 跨平台

源代码(.java) - javac -> 字节码(.class) - jvm -> 机器码。

每个平台都有对应的JVM，因此可以跨平台执行。

## 类加载

### 过程

1. 加载 

   通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象。

2. 链接 

   1. 验证

      目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

   2. 准备

      为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i=5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

   3. 解析

      主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析。
      
      符号引用
      
      ​		符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可，使用符号引用时，被引用的目标不一定已经加载到内存中。
      
      直接引用
      
      ​		直接引用可以是直接指向目标的指针，相对偏移量，一个能间接定位到目标的句柄，使用直接引用时，引用的目标必定已经存在于虚拟机的内存中了
      
      

3. 初始化

   类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。

### 加载器

1. Bootstrap

   启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。

2. Extension

   扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。

3. System

   也称应用程序加载器，是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。

### 双亲委派模式

如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，如果都加载不到，则会抛出ClassNotFoundException。

#### 优势

采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常

```
java.lang.SecurityException: Prohibited package name: java.lang
```

### 执行模式

#### 编译器

将 **源代码** 转换成 **机器语言**，通常是 **二进制形式(机器码) **并保存下来(复用)，等待执行。目的是生成 可执行的程序。
	优点:
		因为提前编译生成 机器码，所以直接执行 编译后的文件即可，因此速度较快。
	缺点:
		源代码编译后只能在该类机器上运行，无法跨平台。

#### 解释器

在程序运行时，将源代码转换为 机器语言(机器码)，并立即执行。
	工作模式:
		1.分析源代码，并且直接执行。
		2.把源代码翻译成相对更加高效率的中间码，然后立即执行它。
		3.执行由解释器内部的编译器预编译后保存的代码。
	优点:
		跨平台性，因为无需编译，因此只要解释器支持多平台，就有跨平台性。
	缺点:
		运行速度慢，解释器要额外的开销。

####JAVA

源码       --编译(javac)-->       字节码       --解释(JVM)-->       机器码

 属于解释执行。为了提高运行效率，JAVA也提供了**直接编译为机器码的** 机制。

##### JIT(Just in time)

运行时，将热点代码的字节码 提前编译为机器码并保存下来，后续直接调用机器码，而无需解释执行，提高程序运行效率。
			热点代码:
				运行时，当某一方法调用次数达到即时编译定义的阈值时，可以将该方法认为 热点代码。
			编译器:
				C1编译器:client模式，根据1500次的收集计算出热点代码。启动性能好，适合启动快的客户端。
				C2编译器:server模式，根据10000次的收集计算出热点代码。峰值性能好，适合长期运行的服务端。

##### AOT(Ahead of time )

运行之前，将应用中或JDK中的字节码编译成机器码(与即时编译器有区别)

### final/finally/finalize

#### fianl
class:
			该类不可继承，因此无法修改
			String为啥定义为final
		method:
			该方法不能被子类重写，可以用于保证框架内部行为不会改变
		variable:
			该引用不可修改，但引用指向的对象不受影响
			immutable   List.of   
			volatile
		标识意义大于性能意义，或许能略微提高性能

#### finally

try-catch-finally:
        	不管是否异常，都会处理finally块，通常用于释放资源
        	try{
           	 // open resources
          	  resource = ...
     	   }catch(Exception e){
       	     // handle exception
       	 }finally{
       	     // close resources
    	        resource.close
     	   }
    try-with-resource:
        resource需要实现Closeable接口，这样可以自动关闭资源。

Closeable extends AutoCloseable
        try(resource)

 有几个特殊的例子:
       		 System.out()不会执行finally语句，因为JVM已经退出
        		如果finally之前有return语句，则return会保存当前现场，执行完finally在返回。如果返回的是基本类型，然后在finally修改该返回值，虽然值修改了，但是返回值不变，因为当时保存了现场数据。如果是引用类型，则只会保存对象的引用，无法保证被引用的对象不被修改。

#### finalize

Object自带的方法，可以在垃圾收集时做一些操作，如释放资源， 但是不推荐使用(JDK9标为@Deprecated)，因为

1. 执行时间不确定，该方法由垃圾回收器调用，而垃圾回收的执行时间无法预知，如果程序终止之前都没有执行垃圾回收操作，那么该方法就不会掉用。显式调用System.gc()或Runtime.gc()方法可以促进垃圾回收的调用，但是不一定立即执行。
2. 性能很差，在垃圾回收前调用，会占用资源，并且延缓垃圾回收的执行
3. finalize()方法有可能使对象复活，使它恢复到可触及状态
4. 垃圾回收器在执行finalize()方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。
       代替方案:
           Cleaner:使用幻像引用操作